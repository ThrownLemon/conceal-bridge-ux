import { ComponentFixture, TestBed } from '@angular/core/testing';
import { By } from '@angular/platform-browser';
import { vi } from 'vitest';

import { ZardToastContainerComponent } from './toast-container.component';
import { ZardToastComponent } from './toast.component';
import { ZardToastService } from './toast.service';

describe('ZardToastContainerComponent', () => {
  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [ZardToastContainerComponent, ZardToastComponent],
      providers: [ZardToastService],
    }).compileComponents();
  });

  describe('isolated tests', () => {
    let component: ZardToastContainerComponent;
    let fixture: ComponentFixture<ZardToastContainerComponent>;
    let toastService: ZardToastService;

    beforeEach(() => {
      fixture = TestBed.createComponent(ZardToastContainerComponent);
      component = fixture.componentInstance;
      toastService = TestBed.inject(ZardToastService);
      fixture.detectChanges();
    });

    afterEach(() => {
      fixture.destroy();
      toastService.clear();
    });

    describe('initialization', () => {
      it('should create the component', () => {
        expect(component).toBeTruthy();
      });

      it('should expose toasts signal from service', () => {
        expect(component.toasts).toBe(toastService.toasts);
      });
    });

    describe('layout and positioning', () => {
      it('should have fixed positioning classes', () => {
        const hostElement = fixture.debugElement.nativeElement;
        expect(hostElement.classList.contains('fixed')).toBe(true);
        expect(hostElement.classList.contains('bottom-0')).toBe(true);
        expect(hostElement.classList.contains('right-0')).toBe(true);
      });

      it('should have proper z-index', () => {
        const hostElement = fixture.debugElement.nativeElement;
        expect(hostElement.classList.contains('z-50')).toBe(true);
      });

      it('should have pointer-events-none on host', () => {
        const hostElement = fixture.debugElement.nativeElement;
        expect(hostElement.classList.contains('pointer-events-none')).toBe(true);
      });

      it('should have flex layout with gap', () => {
        const hostElement = fixture.debugElement.nativeElement;
        expect(hostElement.classList.contains('flex')).toBe(true);
        expect(hostElement.classList.contains('flex-col')).toBe(true);
        expect(hostElement.classList.contains('gap-2')).toBe(true);
      });

      it('should have proper padding', () => {
        const hostElement = fixture.debugElement.nativeElement;
        expect(hostElement.classList.contains('p-4')).toBe(true);
      });

      it('should have max-width constraint', () => {
        const hostElement = fixture.debugElement.nativeElement;
        expect(hostElement.classList.contains('max-w-screen-sm')).toBe(true);
        expect(hostElement.classList.contains('w-full')).toBe(true);
      });

      it('should enable pointer events on container', () => {
        const container = fixture.nativeElement.querySelector('[role="status"]');
        expect(container).toBeTruthy();
        expect(container.classList.contains('pointer-events-auto')).toBe(true);
      });

      it('should use flex-col-reverse for stacking', () => {
        const container = fixture.nativeElement.querySelector('[role="status"]');
        expect(container.classList.contains('flex-col-reverse')).toBe(true);
      });
    });

    describe('accessibility', () => {
      it('should have role="status"', () => {
        const container = fixture.nativeElement.querySelector('[role="status"]');
        expect(container).toBeTruthy();
        expect(container.getAttribute('role')).toBe('status');
      });

      it('should have aria-live="polite"', () => {
        const container = fixture.nativeElement.querySelector('[aria-live="polite"]');
        expect(container).toBeTruthy();
        expect(container.getAttribute('aria-live')).toBe('polite');
      });

      it('should have aria-atomic="true"', () => {
        const container = fixture.nativeElement.querySelector('[aria-atomic="true"]');
        expect(container).toBeTruthy();
        expect(container.getAttribute('aria-atomic')).toBe('true');
      });
    });

    describe('toast rendering', () => {
      it('should render no toasts initially', () => {
        const toasts = fixture.debugElement.queryAll(By.directive(ZardToastComponent));
        expect(toasts.length).toBe(0);
      });

      it('should render a single toast', () => {
        toastService.success('Test message');
        fixture.detectChanges();

        const toasts = fixture.debugElement.queryAll(By.directive(ZardToastComponent));
        expect(toasts.length).toBe(1);
      });

      it('should render multiple toasts', () => {
        toastService.success('Message 1');
        toastService.error('Message 2');
        toastService.info('Message 3');
        fixture.detectChanges();

        const toasts = fixture.debugElement.queryAll(By.directive(ZardToastComponent));
        expect(toasts.length).toBe(3);
      });

      it('should pass correct message to toast component', () => {
        toastService.success('Test message');
        fixture.detectChanges();

        const toastComponent = fixture.debugElement.query(By.directive(ZardToastComponent));
        expect(toastComponent.componentInstance.message()).toBe('Test message');
      });

      it('should pass correct type to toast component', () => {
        toastService.error('Error message');
        fixture.detectChanges();

        const toastComponent = fixture.debugElement.query(By.directive(ZardToastComponent));
        expect(toastComponent.componentInstance.type()).toBe('error');
      });

      it('should pass correct id to toast component', () => {
        const id = toastService.success('Test message');
        fixture.detectChanges();

        const toastComponent = fixture.debugElement.query(By.directive(ZardToastComponent));
        expect(toastComponent.componentInstance.id()).toBe(id);
      });

      it('should track toasts by id in @for loop', () => {
        const id1 = toastService.success('Message 1');
        const id2 = toastService.error('Message 2');
        fixture.detectChanges();

        const toasts = fixture.debugElement.queryAll(By.directive(ZardToastComponent));
        expect(toasts[0].componentInstance.id()).toBe(id1);
        expect(toasts[1].componentInstance.id()).toBe(id2);
      });

      it('should apply pointer-events-auto to toast items', () => {
        toastService.success('Test message');
        fixture.detectChanges();

        const toastElement = fixture.debugElement.query(By.directive(ZardToastComponent)).nativeElement;
        expect(toastElement.classList.contains('pointer-events-auto')).toBe(true);
      });
    });

    describe('toast state management', () => {
      it('should pass visible state to toast component initially', () => {
        toastService.success('Test message');
        fixture.detectChanges();

        const toastComponent = fixture.debugElement.query(By.directive(ZardToastComponent));
        expect(toastComponent.componentInstance.state()).toBe('visible');
      });
    });

    describe('toast dismissal', () => {
      beforeEach(() => {
        vi.useFakeTimers();
      });

      afterEach(() => {
        vi.useRealTimers();
      });

      it('should handle close button click', () => {
        const id = toastService.success('Test message');
        fixture.detectChanges();

        const toastComponent = fixture.debugElement.query(By.directive(ZardToastComponent));
        const closeBtn = toastComponent.nativeElement.querySelector('[data-slot="toast-close"]');

        closeBtn.click();
        fixture.detectChanges();

        // Should be in dismissing set
        expect((getPrivate(component, '#dismissingToasts') as Set<string>).has(id)).toBe(true);
      });

      it('should add toast to dismissing set when close is clicked', () => {
        const id = toastService.success('Test message');
        const toasts = toastService.toasts();
        expect(toasts.length).toBe(1);

        (getPrivate(component, 'handleDismiss') as (id: string) => void)(toasts[0].id);

        expect((getPrivate(component, '#dismissingToasts') as Set<string>).has(toasts[0].id)).toBe(true);
      });

      it('should not process same dismiss twice', () => {
        const id = toastService.success('Test message');
        (getPrivate(component, 'handleDismiss') as (id: string) => void)(id);

        // Try to dismiss again immediately
        const initialSize = (getPrivate(component, '#dismissingToasts') as Set<string>).size;
        (getPrivate(component, 'handleDismiss') as (id: string) => void)(id);

        expect((getPrivate(component, '#dismissingToasts') as Set<string>).size).toBe(initialSize);
      });

      it('should remove toast from service after animation delay', () => {
        const id = toastService.success('Test message');
        expect(toastService.toasts().length).toBe(1);

        (getPrivate(component, 'handleDismiss') as (id: string) => void)(id);

        // Before animation completes, toast still exists
        expect(toastService.toasts().length).toBe(1);
        expect((getPrivate(component, '#dismissingToasts') as Set<string>).has(id)).toBe(true);

        // Fast-forward past animation duration
        vi.advanceTimersByTime(300);

        // After animation, toast should be removed
        expect(toastService.toasts().length).toBe(0);
        expect((getPrivate(component, '#dismissingToasts') as Set<string>).has(id)).toBe(false);
      });

      it('should remove from dismissing set after animation', () => {
        const id = toastService.success('Test message');
        (getPrivate(component, 'handleDismiss') as (id: string) => void)(id);

        expect((getPrivate(component, '#dismissingToasts') as Set<string>).has(id)).toBe(true);

        vi.advanceTimersByTime(300);

        expect((getPrivate(component, '#dismissingToasts') as Set<string>).has(id)).toBe(false);
      });

      it('should handle multiple toasts dismissal independently', () => {
        const id1 = toastService.success('Message 1');
        const id2 = toastService.error('Message 2');
        const id3 = toastService.info('Message 3');

        expect(toastService.toasts().length).toBe(3);

        // Dismiss middle toast
        (getPrivate(component, 'handleDismiss') as (id: string) => void)(id2);

        expect((getPrivate(component, '#dismissingToasts') as Set<string>).has(id1)).toBe(false);
        expect((getPrivate(component, '#dismissingToasts') as Set<string>).has(id2)).toBe(true);
        expect((getPrivate(component, '#dismissingToasts') as Set<string>).has(id3)).toBe(false);

        vi.advanceTimersByTime(300);

        expect(toastService.toasts().length).toBe(2);
        expect((getPrivate(component, '#dismissingToasts') as Set<string>).size).toBe(0);
      });
    });

    describe('toast updates and reactivity', () => {
      it('should update when new toast is added', () => {
        expect(fixture.debugElement.queryAll(By.directive(ZardToastComponent)).length).toBe(0);

        toastService.success('New message');
        fixture.detectChanges();

        expect(fixture.debugElement.queryAll(By.directive(ZardToastComponent)).length).toBe(1);
      });

      it('should update when toast is removed', () => {
        const id = toastService.success('Message');
        fixture.detectChanges();

        expect(fixture.debugElement.queryAll(By.directive(ZardToastComponent)).length).toBe(1);

        toastService.dismiss(id);
        fixture.detectChanges();

        expect(fixture.debugElement.queryAll(By.directive(ZardToastComponent)).length).toBe(0);
      });

      it('should update when all toasts are cleared', () => {
        toastService.success('Message 1');
        toastService.error('Message 2');
        toastService.info('Message 3');
        fixture.detectChanges();

        expect(fixture.debugElement.queryAll(By.directive(ZardToastComponent)).length).toBe(3);

        toastService.clear();
        fixture.detectChanges();

        expect(fixture.debugElement.queryAll(By.directive(ZardToastComponent)).length).toBe(0);
      });

      it('should reactively update toast state during dismissal', () => {
        const id = toastService.success('Test message');
        fixture.detectChanges();

        let toastComponent = fixture.debugElement.query(By.directive(ZardToastComponent));
        expect(toastComponent.componentInstance.state()).toBe('visible');

        (getPrivate(component, 'handleDismiss') as (id: string) => void)(id);
        fixture.detectChanges();

        toastComponent = fixture.debugElement.query(By.directive(ZardToastComponent));
        expect(toastComponent.componentInstance.state()).toBe('exiting');
      });
    });

    describe('edge cases', () => {
      it('should handle rapid toast additions', () => {
        for (let i = 0; i < 10; i++) {
          toastService.info(`Message ${i}`);
        }
        fixture.detectChanges();

        const toasts = fixture.debugElement.queryAll(By.directive(ZardToastComponent));
        expect(toasts.length).toBe(10);
      });

      it('should handle toast with custom duration', () => {
        toastService.show({ message: 'Long toast', duration: 10000 });
        fixture.detectChanges();

        const toastComponent = fixture.debugElement.query(By.directive(ZardToastComponent));
        expect(toastComponent).toBeTruthy();
        expect(toastComponent.componentInstance.message()).toBe('Long toast');
      });

      it('should handle toast with custom ID', () => {
        const customId = 'my-custom-toast-id';
        toastService.show({ message: 'Custom ID toast', id: customId });
        fixture.detectChanges();

        const toastComponent = fixture.debugElement.query(By.directive(ZardToastComponent));
        expect(toastComponent.componentInstance.id()).toBe(customId);
      });

      it('should handle empty toasts array after clear', () => {
        toastService.success('Message');
        toastService.clear();
        fixture.detectChanges();

        const toasts = fixture.debugElement.queryAll(By.directive(ZardToastComponent));
        expect(toasts.length).toBe(0);
      });

      it('should handle dismiss of non-existent toast gracefully', () => {
        // Should not throw error
        (getPrivate(component, 'handleDismiss') as (id: string) => void)('non-existent-id');
        fixture.detectChanges();

        expect(toastService.toasts().length).toBe(0);
      });

      it('should handle very long message in toast', () => {
        const longMessage = 'A'.repeat(1000);
        toastService.success(longMessage);
        fixture.detectChanges();

        const toastComponent = fixture.debugElement.query(By.directive(ZardToastComponent));
        expect(toastComponent.componentInstance.message()).toBe(longMessage);
      });
    });

    describe('computed properties', () => {
      it('should compute hostClasses correctly', () => {
        const hostClasses = getPrivate(component, 'hostClasses') as () => string;
        const classes = hostClasses();
        expect(classes).toContain('fixed');
        expect(classes).toContain('bottom-0');
        expect(classes).toContain('right-0');
        expect(classes).toContain('z-50');
      });

      it('should compute containerClasses correctly', () => {
        const containerClasses = getPrivate(component, 'containerClasses') as () => string;
        const classes = containerClasses();
        expect(classes).toContain('flex');
        expect(classes).toContain('flex-col-reverse');
        expect(classes).toContain('pointer-events-auto');
      });

      it('should compute toastItemClasses correctly', () => {
        const toastItemClasses = getPrivate(component, 'toastItemClasses') as () => string;
        const classes = toastItemClasses();
        expect(classes).toContain('pointer-events-auto');
      });
    });

    describe('integration with toast service', () => {
      it('should subscribe to toasts signal changes', () => {
        expect(component.toasts()).toEqual([]);

        toastService.success('Test');
        fixture.detectChanges();

        expect(component.toasts().length).toBe(1);
      });

      it('should share same toasts signal with service', () => {
        expect(component.toasts).toBe(toastService.toasts);
      });

      it('should reflect service changes immediately', () => {
        const id = toastService.success('First');

        expect(component.toasts().length).toBe(1);
        expect(component.toasts()[0].message).toBe('First');

        toastService.dismiss(id);

        expect(component.toasts().length).toBe(0);
      });
    });

    describe('toast ordering', () => {
      it('should maintain toast order from service', () => {
        toastService.success('First');
        toastService.error('Second');
        toastService.info('Third');
        fixture.detectChanges();

        const toasts = fixture.debugElement.queryAll(By.directive(ZardToastComponent));
        expect(toasts[0].componentInstance.message()).toBe('First');
        expect(toasts[1].componentInstance.message()).toBe('Second');
        expect(toasts[2].componentInstance.message()).toBe('Third');
      });

      it('should maintain order after removing middle toast', () => {
        const id1 = toastService.success('First');
        const id2 = toastService.error('Second');
        const id3 = toastService.info('Third');

        toastService.dismiss(id2);
        fixture.detectChanges();

        const toasts = fixture.debugElement.queryAll(By.directive(ZardToastComponent));
        expect(toasts.length).toBe(2);
        expect(toasts[0].componentInstance.message()).toBe('First');
        expect(toasts[1].componentInstance.message()).toBe('Third');
      });
    });
  });
});
